package filewriter

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// FileWriter handles writing files to the filesystem
type FileWriter struct {
	projectRoot string
}

// New creates a new FileWriter
func New(projectRoot string) *FileWriter {
	return &FileWriter{
		projectRoot: projectRoot,
	}
}

// WriteFile writes content to a file with proper directory structure
func (fw *FileWriter) WriteFile(relativePath, content string) error {
	fullPath := filepath.Join(fw.projectRoot, relativePath)
	
	// Create directory if it doesn't exist
	dir := filepath.Dir(fullPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}
	
	// Write file
	if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %w", fullPath, err)
	}
	
	return nil
}

// WritePackageJSON creates a package.json file
func (fw *FileWriter) WritePackageJSON(projectName string, dependencies map[string]string) error {
	content := fmt.Sprintf(`{
  "name": "%s",
  "version": "1.0.0",
  "description": "Generated by go-code AI development team",
  "main": "app.js",
  "scripts": {
    "start": "node app.js",
    "dev": "nodemon app.js",
    "test": "jest"
  },
  "dependencies": {`, projectName)
	
	var deps []string
	for name, version := range dependencies {
		deps = append(deps, fmt.Sprintf(`    "%s": "%s"`, name, version))
	}
	content += "\n" + strings.Join(deps, ",\n") + "\n"
	
	content += `  },
  "devDependencies": {
    "nodemon": "^2.0.0",
    "jest": "^27.0.0"
  }
}`
	
	return fw.WriteFile("package.json", content)
}

// ExtractCodeBlocks extracts code blocks from agent responses
func (fw *FileWriter) ExtractCodeBlocks(response string) map[string]string {
	codeBlocks := make(map[string]string)
	
	// Regex to match code blocks with optional language
	codeBlockRegex := regexp.MustCompile("(?s)```(?:[a-zA-Z]*)\n(.*?)\n```")
	
	matches := codeBlockRegex.FindAllStringSubmatch(response, -1)
	
	blockIndex := 0
	for _, match := range matches {
		if len(match) > 1 {
			code := strings.TrimSpace(match[1])
			
			// Skip empty code blocks
			if code == "" {
				continue
			}
			
			// Look for LLM-generated filename patterns
			filename := fw.extractLLMFilename(code, blockIndex)
			
			codeBlocks[filename] = code
			blockIndex++
		}
	}
	
	return codeBlocks
}

// extractLLMFilename extracts filename from LLM-generated code
func (fw *FileWriter) extractLLMFilename(code string, index int) string {
	// Look for various filename comment patterns that LLMs might use
	patterns := []string{
		`// filename: ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+)`,
		`<!-- filename: ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+) -->`,
		`# filename: ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+)`,
		`/\* filename: ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+) \*/`,
		`// ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+)`,
		`<!-- ([a-zA-Z0-9/_.-]+\.[a-zA-Z]+) -->`,
	}
	
	for _, pattern := range patterns {
		regex := regexp.MustCompile(pattern)
		if matches := regex.FindStringSubmatch(code); len(matches) > 1 {
			return matches[1]
		}
	}
	
	// If no explicit filename, use content-based inference as fallback
	return fw.inferFilename(code, index)
}

// inferFilename tries to infer filename from code content
func (fw *FileWriter) inferFilename(code string, index int) string {
	lowerCode := strings.ToLower(code)
	
	// Look for comment patterns that indicate filenames
	fileCommentRegex := regexp.MustCompile(`(?:// |/\* )([a-zA-Z0-9/_.-]+\.[a-zA-Z]+)`)
	if matches := fileCommentRegex.FindStringSubmatch(code); len(matches) > 1 {
		return matches[1]
	}
	
	// Check for specific file patterns
	if strings.Contains(lowerCode, "package.json") || (strings.Contains(lowerCode, `"name":`) && strings.Contains(lowerCode, `"dependencies"`)) {
		return "package.json"
	}
	
	if strings.Contains(lowerCode, "create table") || strings.Contains(lowerCode, "database") {
		return "database/schema.sql"
	}
	
	if strings.Contains(lowerCode, "mongoose") && strings.Contains(lowerCode, "schema") {
		if strings.Contains(lowerCode, "user") {
			return "models/User.js"
		}
		if strings.Contains(lowerCode, "post") {
			return "models/Post.js"
		}
		return "models/Model.js"
	}
	
	if strings.Contains(lowerCode, "connectdb") || strings.Contains(lowerCode, "mongoose.connect") {
		return "database/index.js"
	}
	
	if strings.Contains(lowerCode, "router") || strings.Contains(lowerCode, "express.router") {
		if strings.Contains(lowerCode, "user") {
			return "routes/users.js"
		}
		if strings.Contains(lowerCode, "auth") {
			return "routes/auth.js"
		}
		return "routes/api.js"
	}
	
	if strings.Contains(lowerCode, "middleware") || strings.Contains(lowerCode, "authenticate") {
		return "middleware/auth.js"
	}
	
	if strings.Contains(lowerCode, "joi") || strings.Contains(lowerCode, "validate") {
		return "utils/validation.js"
	}
	
	if strings.Contains(lowerCode, "app.listen") || strings.Contains(lowerCode, "server listening") {
		if strings.Contains(lowerCode, "require('./app')") {
			return "server.js"
		}
		return "app.js"
	}
	
	if strings.Contains(lowerCode, "const express") && strings.Contains(lowerCode, "app = express") {
		return "app.js"
	}
	
	// Default naming with proper subfolder
	return fmt.Sprintf("generated/generated%d.js", index)
}

// CreateProjectStructure creates a basic project structure
func (fw *FileWriter) CreateProjectStructure() error {
	dirs := []string{
		"src",
		"models",
		"routes",
		"controllers",
		"middleware",
		"config",
		"utils",
		"tests",
	}
	
	for _, dir := range dirs {
		fullPath := filepath.Join(fw.projectRoot, dir)
		if err := os.MkdirAll(fullPath, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", fullPath, err)
		}
	}
	
	return nil
}